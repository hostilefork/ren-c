//
//  File: %sys-kinds.h
//  Summary: -{Safe wrapper for distinguishing "Heart" and "Kind" if C++}-
//  Project: "Rebol 3 Interpreter and Run-time (Ren-C branch)"
//  Homepage: https://github.com/metaeducation/ren-c/
//
//=////////////////////////////////////////////////////////////////////////=//
//
// Copyright 2012 REBOL Technologies
// Copyright 2012-2023 Ren-C Open Source Contributors
// REBOL is a trademark of REBOL Technologies
//
// See README.md and CREDITS.md for more information
//
// Licensed under the Lesser GPL, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.gnu.org/licenses/lgpl-3.0.html
//
//=////////////////////////////////////////////////////////////////////////=//
//
// There is a basic idea in the system that tests like Is_Word() or WORD? do
// not consider quoted words (or quasi-words, or anti-words) to be "Word".
// They may have a cell layout and payload that carries a symbol and a binding
// like a word, but should not be confused with them.
//
// This distinction has led to a difference in considering the "VAL_TYPE()" of
// a cell in comparison with the "Cell_Heart()".  If you ask a word at any
// quoting level what the heart of the cell is, it will say REB_WORD.  But
// only a word at the NOQUOTE_1 quoting level will respond with REB_WORD to
// VAL_TYPE().  Otherwise it gives REB_QUOTED, REB_QUASIFORM, or REB_ANTIFORM
// as appropriate.
//
// This means that the extra "types" generated by quoting states are not
// "cell hearts" describing their layout, but a sort of "pseudotype".  It
// would be incorrect to put these values into a cell's heart, and it's also
// make-work to check for them when you're sure you're dealing with something
// that is constrained to being a valid cell heart.
//
// Unfortunately, there's no such thing as "enum inheritance" in C++ to step
// in and help, by making the result of VAL_TYPE() a superset of states that
// are returned from Cell_Heart(), and prohibiting passing the superset
// state to routines that only expect the subset.  This file does the next
// best thing by making a wrapper class that can accept either of two
// enums as initialization, but can only be passed where the superset is
// accepted.
//
// **THIS ONLY SEEMS TO WORK IN MSVC AND GCC, CLANG HAS MORE AGGRESSIVE
//   IMPLEMENTATIONS OF THE -Wenum-compare WARNING!!!**.
//
// 1. The technique requires splitting the enum into two parts (where the
//    KindEnum has dummy values to cover the HeartEnum cases so that switch()
//    statements on a KindEnum doesn't trigger a warning checking against
//    REB_XXX integral values that it doesn't have an integer for).  But
//    if you're not using the classes there are enum comparison errors.
//    A consolidated enum seems to have to be used if you're not going to
//    be doing the class trick.
//
// 2. Originally there were two explicit conversion operators in Kind to
//    handle the cases of Heart and SymId.  This worked fine in GCC, but
//    MSVC's left shift operator seemed to be able to find not only the
//    implicit operator but also the explicit ones, considering it to
//    be ambiguous.  So this uses the cast_helper<> tool instead, since the
//    calls all use the `cast()` macro anyway.
//

#if (! CPLUSPLUS_11 || ! DEBUG || defined(__clang__))
    typedef enum HeartKindEnum Heart;  // avoid enum compare warnings [1]
    typedef enum HeartKindEnum Kind;
#else
    typedef enum HeartEnum Heart;

    struct Kind {
        Byte byte;

        Kind () = default;
        Kind (enum HeartEnum heart) : byte (heart) {}
        Kind (enum KindEnum kind) : byte (kind) {}
        explicit Kind (Byte byte) : byte {byte} {}
        explicit Kind (SymId id) {
            assert(cast(uint16_t, id) < REB_MAX);
            byte = id;
        }

        operator enum KindEnum()
          { return u_cast(enum KindEnum, byte); }

        bool operator==(enum HeartEnum heart)
          { return byte == heart; }
    };

    template<>  // explicit conversion operators ambiguous in MSVC [2]
    struct cast_helper<Kind,Heart> {
        static Heart convert(Kind kind)
          { return static_cast<Heart>(kind.byte); }
    };

    template<>  // explicit conversion operators ambiguous in MSVC [2]
    struct cast_helper<Kind,SymId> {
        static SymId convert(Kind kind)
          { return static_cast<SymId>(kind.byte);}
    };
#endif


//=//// SINGLEHEART OPTIMIZED SEQUENCE TYPE ///////////////////////////////=//
//
// In Ren-C, `/foo` is a 2-element PATH! with a blank at the head, and `bar:`
// is a 2-element CHAIN! with a blank at the tail.  Due to how common these
// are, and the fact that they are immutable sequences, there is investment
// in optimizing them.  They are called "SingleHeart" sequences, and because
// detection of these is so common there's a special type which multiplexes
// both the Heart and whether there is a blank at the head or tail.
//
// (It's encoded in a single type, because if the leading blank or trailing
// blank were separated from the heart type, you could accidentally check
// the leading blank or trailing blank without verifying a sequence was a
// single hearted type.  Static analysis caught bugs of that kind, and they
// are easy to make.)
//
// This is defined as an enum type because we want to use it in a switch()
// but don't want to generically turn it into an integer, because that would
// mean you could accidentally test against Heart like REB_CHAIN etc. and
// that would be incorrect, due to the multiplexed information.

typedef enum SingleHeartEnum SingleHeart;

#define Leading_Blank_And(heart)    u_cast(SingleHeart, ((heart) << 8) + 1)
#define Trailing_Blank_And(heart)   u_cast(SingleHeart, (heart) << 8)

#define LEADING_BLANK_AND(name)     Leading_Blank_And(REB_##name)
#define TRAILING_BLANK_AND(name)    Trailing_Blank_And(REB_##name)

INLINE bool Singleheart_Has_Leading_Blank(SingleHeart single) {
    assert(single != NOT_SINGLEHEART_0);
    return did (u_cast(uint_fast16_t, single) & 1);
}

#define Singleheart_Has_Trailing_Blank(single) \
    (not Singleheart_Has_Leading_Blank(single))

INLINE Heart Heart_Of_Singleheart(SingleHeart single) {
    assert(single != NOT_SINGLEHEART_0);
    Heart heart = u_cast(Heart, u_cast(uint_fast16_t, single) >> 8);
    assert(heart != REB_0 and heart != REB_BLANK);
    return heart;
}
