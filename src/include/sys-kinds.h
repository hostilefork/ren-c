//
//  File: %sys-kinds.h
//  Summary: {Safe wrapper for distinguishing "Heart" and "Kind" if C++}
//  Project: "Rebol 3 Interpreter and Run-time (Ren-C branch)"
//  Homepage: https://github.com/metaeducation/ren-c/
//
//=////////////////////////////////////////////////////////////////////////=//
//
// Copyright 2012 REBOL Technologies
// Copyright 2012-2023 Ren-C Open Source Contributors
// REBOL is a trademark of REBOL Technologies
//
// See README.md and CREDITS.md for more information
//
// Licensed under the Lesser GPL, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.gnu.org/licenses/lgpl-3.0.html
//
//=////////////////////////////////////////////////////////////////////////=//
//
// There is a basic idea in the system that tests like Is_Word() or WORD? do
// not consider quoted words (or quasi-words, or anti-words) to be "Word".
// They may have a cell layout and payload that carries a symbol and a binding
// like a word, but should not be confused with them.
//
// This distinction has led to a difference in considering the "VAL_TYPE()" of
// a cell in comparison with the "Cell_Heart()".  If you ask a word at any
// quoting level what the heart of the cell is, it will say REB_WORD.  But
// only a word at the NOQUOTE_1 quoting level will respond with REB_WORD to
// VAL_TYPE().  Otherwise it gives REB_QUOTED, REB_QUASIFORM, or REB_ANTIFORM
// as appropriate.
//
// This means that the extra "types" generated by quoting states are not
// "cell hearts" describing their layout, but a sort of "pseudotype".  It
// would be incorrect to put these values into a cell's heart, and it's also
// make-work to check for them when you're sure you're dealing with something
// that is constrained to being a valid cell heart.
//
// Unfortunately, there's no such thing as "enum inheritance" in C++ to step
// in and help, by making the result of VAL_TYPE() a superset of states that
// are returned from Cell_Heart(), and prohibiting passing the superset
// state to routines that only expect the subset.  This file does the next
// best thing by making a wrapper class that can accept either of two
// enums as initialization, but can only be passed where the superset is
// accepted.
//
// **THIS ONLY SEEMS TO WORK IN MSVC AND GCC, CLANG HAS MORE AGGRESSIVE
//   IMPLEMENTATIONS OF THE -Wenum-compare WARNING!!!**.
//
// 1. The technique requires splitting the enum into two parts (where the
//    KindEnum has dummy values to cover the HeartEnum cases so that switch()
//    statements on a KindEnum doesn't trigger a warning checking against
//    REB_XXX integral values that it doesn't have an integer for).  But
//    if you're not using the classes there are enum comparison errors.
//    A consolidated enum seems to have to be used if you're not going to
//    be doing the class trick.
//
// 2. Originally there were two explicit conversion operators in Kind to
//    handle the cases of Heart and SymId.  This worked fine in GCC, but
//    MSVC's left shift operator seemed to be able to find not only the
//    implicit operator but also the explicit ones, considering it to
//    be ambiguous.  So this uses the cast_helper<> tool instead, since the
//    calls all use the `cast()` macro anyway.
//

#if (! CPLUSPLUS_11 || ! DEBUG || defined(__clang__))
    typedef enum HeartKindEnum Heart;  // avoid enum compare warnings [1]
    typedef enum HeartKindEnum Kind;
#else
    typedef enum HeartEnum Heart;

    struct Kind {
        Byte byte;

        Kind () = default;
        Kind (enum HeartEnum heart) : byte (heart) {}
        Kind (enum KindEnum kind) : byte (kind) {}
        explicit Kind (Byte byte) : byte {byte} {}
        explicit Kind (SymId id) {
            assert(cast(uint16_t, id) < REB_MAX);
            byte = id;
        }

        operator enum KindEnum()
          { return u_cast(enum KindEnum, byte); }

        bool operator==(enum HeartEnum heart)
          { return byte == heart; }
    };

    template<>  // explicit conversion operators ambiguous in MSVC [2]
    struct cast_helper<Kind,Heart> {
        static Heart convert(Kind kind)
          { return static_cast<Heart>(kind.byte); }
    };

    template<>  // explicit conversion operators ambiguous in MSVC [2]
    struct cast_helper<Kind,SymId> {
        static SymId convert(Kind kind)
          { return static_cast<SymId>(kind.byte);}
    };
#endif
