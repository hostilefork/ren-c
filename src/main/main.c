//
//  file: %main.c
//  summary: "Console application main entry point"
//  project: "Rebol 3 Interpreter and Run-time (Ren-C branch)"
//  homepage: https://github.com/metaeducation/ren-c/
//
//=////////////////////////////////////////////////////////////////////////=//
//
// Copyright 2012-2025 Ren-C Open Source Contributors
// Copyright 2012 REBOL Technologies
// REBOL is a trademark of REBOL Technologies
//
// See README.md and CREDITS.md for more information.
//
// Licensed under the Lesser GPL, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.gnu.org/licenses/lgpl-3.0.html
//
//=////////////////////////////////////////////////////////////////////////=//
//
// This contains the main() routine, which uses the libRebol API to start up
// an interactive console system for environments that can compile C.
//
// Very little work is done in C.  For instance, the command line arguments
// are processed using PARSE by Rebol code that is embedded into the
// executable as compressed bytes.  And the majority of the console behavior
// is defined by Rebol code in %extensions/console (though it has some of
// its own C to handle things like SIGINT for Ctrl-C handling).
//

#include "reb-config.h"

#include <stdlib.h>
#include <string.h>

#include <stdint.h>
#include <stdbool.h>

#include "assert-fix.h"

#if TO_WINDOWS
    #undef _WIN32_WINNT  // https://forum.rebol.info/t/326/4
    #define _WIN32_WINNT 0x0501  // Minimum API target: WinXP
    #define WIN32_LEAN_AND_MEAN  // trim down the Win32 headers
    #include <windows.h>

    #include <shellapi.h>  // for CommandLineToArgvW()
#endif

#define DUMP_ADDRESS_SANITIZER_REACHABILITY  0

#if DUMP_ADDRESS_SANITIZER_REACHABILITY
    #include <sanitizer/common_interface_defs.h>  // for printing reachable
#endif

// This file should only use the external API.  However, it can be helpful in
// debug situations to have access to PROBE() and other internal features.
//
#define DEBUG_MAIN_USING_SYS_CORE 0
#if (! DEBUG_MAIN_USING_SYS_CORE)
    #include "rebol.h"
    typedef RebolValue Value;
#else
    #undef OUT  // %minwindef.h defines this, we have a better use for it
    #undef VOID  // %winnt.h defines this, we have a better use for it
    #include "sys-core.h"
#endif

#include "needful/needful.h"  // provides cast(), UNUSED(), etc.

#include "c-extras.h"  // provides INLINE, nullptr, etc.


// Initialization done by rebStartup() is intended to be as basic as possible
// in order to get the Rebol series/values/list functions ready to be run.
// Once that's ready, the rest of the initialization can take advantage of
// a working evaluator.  This includes PARSE to process the command line
// parameters, or PRINT to output boot banners.
//
// This is the %main-startup.reb file bundled with other modules, compressed
// with Gzip and expressed as a C byte array literal.  That is TRANSCODE'd
// and executed to return the MAIN-STARTUP function, which takes the command
// line arguments as a block of TEXT! and handles things from there.
//
#include "tmp-main-startup.inc"  // generated by %prep-main.reb


#if TO_WINDOWS
    //
    // Most Windows-specific code is expected to be run in extensions (or
    // in the interim, in "devices").  However, it's expected that all Windows
    // code be able to know its `HINSTANCE`.  This is usually passed in a
    // WinMain(), but since we don't use WinMain() in order to be able to
    // act as a console app -or- a GUI app some tricks are needed to capture
    // it, and then export it for other code to use.
    //
    // !!! This is not currently exported via EXTERN_C, because the core was
    // building in a dependency on the host.  This created problems for the
    // libRebol, which needs to be independent of %host-main.c, and may be
    // used with clients that do not have the HINSTANCE easily available.
    // The best idea for exporting it is probably to have those clients who
    // provide it to inject it into the system object as a HANDLE!, so that
    // those extensions which need it have access to it, while not creating
    // problems for those that do not.
    //
    HINSTANCE g_app_instance = 0;

    // For why this is done this way with a potential respawning, see the
    // StackOverflow question:
    //
    // "Can one executable be both a console and a GUI application":
    //
    //     http://stackoverflow.com/q/493536/
    //
    void Determine_Hinstance_May_Respawn(WCHAR* this_exe_path) {
        if (GetStdHandle(STD_OUTPUT_HANDLE) == INVALID_HANDLE_VALUE) {
            //
            // No console to attach to, we must be the DETACHED_PROCESS which
            // was spawned in the below branch.
            //
            g_app_instance = GetModuleHandle(nullptr);
        }
        else {
          #ifdef REB_CORE
            //
            // In "Core" mode, use a console but do not initialize graphics.
            // (stdio redirection works, blinking console window during start)
            //
            g_app_instance = p_cast(HINSTANCE,
                GetWindowLongPtr(GetConsoleWindow(), GWLP_HINSTANCE)
            );
            UNUSED(this_exe_path);
          #else
            //
            // In the "GUI app" mode, stdio redirection doesn't work properly,
            // but no blinking console window during start.
            //
            if (not this_exe_path) {  // argc was > 1
                g_app_instance = p_cast(HINSTANCE,
                    GetWindowLongPtr(GetConsoleWindow(), GWLP_HINSTANCE)
                );
            }
            else {
                // Launch child as a DETACHED_PROCESS so that GUI can be
                // initialized, and exit.
                //
                STARTUPINFO startinfo;
                ZeroMemory(&startinfo, sizeof(startinfo));
                startinfo.cb = sizeof(startinfo);

                PROCESS_INFORMATION procinfo;
                if (not CreateProcess(
                    nullptr,  // lpApplicationName
                    this_exe_path,  // lpCommandLine
                    nullptr,  // lpProcessAttributes
                    nullptr,  // lpThreadAttributes
                    FALSE,  // bInheritHandles
                    CREATE_DEFAULT_ERROR_MODE | DETACHED_PROCESS,
                    nullptr,  // lpEnvironment
                    nullptr,  // lpCurrentDirectory
                    &startinfo,
                    &procinfo
                )){
                    MessageBox(
                        nullptr,  // owner window
                        L"CreateProcess() failed in %host-main.c",
                        this_exe_path,  // title
                        MB_ICONEXCLAMATION | MB_OK
                    );
                }

                exit(0);
            }
          #endif
        }
    }
#endif


//=//// MAIN ENTRY POINT //////////////////////////////////////////////////=//
//
// Using a main() entry point for a console program (as opposed to WinMain())
// so we can connect to the console.  See Determine_Hinstance_May_Respawn().
//
int main(int argc, char *argv_ansi[])
{
    int exit_status;

  startup_the_interpreter: {

  // Note: By default, Ctrl-C is not hooked or handled.  This is done by the
  // console extension (%extensions/console).  Halting should not be possible
  // while the mezzanine is loading, so Ctrl-C should just exit to the OS.

    rebStartup();

} convert_argv_to_cells: {

  // With interpreter startup done, we want to turn the platform-dependent
  // argument strings into a block of Rebol strings as soon as possible.
  // That way the command line argument processing can be taken care of by
  // PARSE in the MAIN-STARTUP user function, instead of C code!
  //
  // 1. Were we using WinMain we'd be getting our arguments in Unicode, but
  //    since we're using an ordinary main() we do not.  But Windows APIs
  //    let us slip out and pick up the arguments in Unicode form (UTF-16).

    Value* argv_block = rebValue("[]");

  #if TO_WINDOWS  // use trick to get main() args in Unicode [1]
    WCHAR **argv_utf16 = CommandLineToArgvW(GetCommandLineW(), &argc);
    UNUSED(argv_ansi);

    Determine_Hinstance_May_Respawn(argc > 1 ? nullptr : argv_utf16[0]);

    int i;
    for (i = 0; i != argc; ++i) {
        rebElide("append", argv_block, rebR(rebTextWide(argv_utf16[i])));
    }
  #else  // use ANSI-C Unicode args as char*, hopefully in UTF-8 [2]
    int i = 0;
    for (; i != argc; ++i) {
        rebElide("append", argv_block, rebT(argv_ansi[i]));
    }
  #endif

 extract_startup_code: {

  // The embedded startup data contains the source code for several basic
  // modules that are useful to have built in:
  //
  //   * Compressing and Decompressing .ZIP files
  //   * Encapping and un-Encapping data into an R3 Executable
  //   * Support for HTTP and TLS/HTTPS Protocols (needs Crypt extension)
  //   * Experimental code not yet written as natives
  //
  // The string of code is stylized to look like:
  //
  //     import module [Name: Zip ...] [...]
  //     import module [Name: Encap ...] [...]
  //     ...
  //     import module [Name: Main-Startup ...] [...]
  //     main-startup/
  //
  // There are no top-level SET-WORD!s, and it doesn't leak any declarations
  // into LIB.  The last value being MAIN-STARTUP/ means the evaluation will
  // synthesize a usermode function that is ready to process the command line
  // arguments.
  //
  // 1. The startup code was compressed with gzip, and embedded as bytes in
  //    a C global variable.  Use the GUNZIP function to make a BLOB! of bytes
  //    from that static data.  (GUNZIP accepts a HANDLE! as input, so pass it
  //    in here).
  //
  // 2. rebHandle() takes a mutable void*.  This is a common C problem, of
  //    having to tunnel using either a const pointer or not.  The API should
  //    probably offer const and non-const HANDLE! constructors, and have
  //    runtime checks disallowing mutable extractions of const pointers.

    Value* startup_bin = rebValue(
        "gunzip", rebR(rebHandle(  // uncompress [1]
            m_cast(unsigned char*, &Main_Startup_Code[0]),  // mutable [2]
            MAIN_STARTUP_SIZE,
            nullptr
        ))
    );

    Value* main_startup = rebValue(
        "ensure action! eval inside lib transcode", rebR(startup_bin)
    );

  run_startup_code_to_get_its_evaluation_requests: {

  // This runs MAIN-STARTUP, which returns a *request* to execute arbitrary
  // code (such as `--do` code on the command line) by way of its return
  // results.  ENRESCUE is thus to intercept bugs *in MAIN-STARTUP itself*.

    Value* enrecovered = rebValue(
        "sys.util/enrecover [",  // MAIN-STARTUP takes one argument (argv[])
            rebRUN(main_startup), rebR(argv_block),
        "]"
    );
    rebRelease(main_startup);

    if (rebUnboxLogic("warning?", enrecovered))  // error in MAIN-STARTUP itself
        rebJumps("crash", enrecovered);  // terminates

    Value* code = rebValue("unlift @", enrecovered);  // non-errors are ^META
    rebRelease(enrecovered);

  delegate_evals_to_console_may_start_interactive_session: {

  // If you pass any scripts or code on the command line, such as:
  //
  //    $ r3 --do "cycle [print -[infinite loop...]-]"
  //
  // There needs to be handling of Ctrl-C, hooking it at the right times to
  // queue an interruption (and how that affects the ability to set unix flags
  // for unblocking file-I/O) to protecting against other kinds of errors.
  //
  // This is sensitive platform-specific code, which is already implemented in
  // the CONSOLE extension.  So even if you aren't invoking an interactive
  // session, we pass the usermode requests to the console via the :PROVOKE
  // refinement.  This feeds it an instruction, as if the user had entered
  // it directly at the prompt.

    Value* result = rebValue("console:provoke", rebR(code));

    exit_status = rebUnboxInteger(rebR(result));

}}}} shutdown_the_interpreter: {

  // Since we are just exiting to the OS here, we typically don't need to do
  // a "clean" shutdown of the interpreter.  This only runs semantically
  // important functions (like closing open files to flush writes) and does
  // not do things like free() all malloc()s...since the OS takes care of
  // that automatically.
  //
  // (Note: the RUNTIME_CHECKS build runs a clean shutdown regardless.)

    const bool clean = (DUMP_ADDRESS_SANITIZER_REACHABILITY == 1);
    rebShutdown(clean);

} dump_address_sanitizer_reachability_if_requested: {

  // Unlike Valgrind, Address Sanitizer does not default to reporting all
  // pointers that were malloc()'d but not free()'d.  If the variable is
  // reachable from a global variable on shutdown, it's considered "ok":
  //
  //   https://stackoverflow.com/q/55510739/addresssanitizer-global-variable
  //
  // If you want a report that's like what you'd get from Valgrind "memcheck"
  // you actually have to call a function in the address sanitizer API in
  // order to do it.  However, known system functions on Linux "leak" in
  // this fashion, so it will have some false positives.
  //
  // The false positives cannot be filtered by LSAN_OPTIONS="suppressions=..."
  // if they are dumped using this function.  So if you decide to use this
  // you'll have to manually inspect the output for any false positives.

  #if DUMP_ADDRESS_SANITIZER_REACHABILITY
    size_t top_percent = 100;
    size_t max_number_of_contexts = 20;
    __sanitizer_print_memory_profile(top_percent, max_number_of_contexts);
  #endif

} finished: {

    return exit_status;  // http://stackoverflow.com/q/1101957/
}}
